//! Attributes to generate client and server implementations.
use proc_macro::TokenStream;
use quote::quote;
use std::str::FromStr;
use syn::spanned::Spanned;
use syn::{Attribute, Fields, Generics, Ident, Lit, Meta, NestedMeta, Result, Visibility};

pub struct ServerAttrs {
    pub trait_name: syn::Ident,
    pub buffer: usize, // in bytes
}

pub fn gen_server_struct(
    name: proc_macro2::Ident,
    attrs: Vec<Attribute>,
    vis: Visibility,
    generics: Generics,
    fields: Fields,
    opts: &ServerAttrs,
) -> proc_macro::TokenStream {
    // duplicate names and types of fields, because quote! moves them
    let initialiser_names: Vec<_> = fields.iter().map(|f| f.ident.clone()).collect();
    let arg_names: Vec<_> = fields.iter().map(|f| f.ident.clone()).collect();
    let arg_types: Vec<_> = fields.iter().map(|f| f.ty.clone()).collect();
    let field_iter = fields.iter();
    let ServerAttrs { trait_name, buffer } = opts;
    // Implement caching, if requested, needs a struct member, code in the new
    // function and impl blocks
    let (cmember, cnew, cimpl) = match buffer {
        0 => (quote! {}, quote! {}, quote! {}),
        n => (
            quote! { __buffer: [u8; #n], },
            quote! { __buffer: [0u8; #n], },
            quote! {
                impl l4::ipc::server::StackBuf for #name {
                    #[inline]
                    fn get_buffer(&mut self) -> &mut [u8] {
                        &mut self.__buffer
                    }
                    #[inline]
                    fn get_buffer_size(&self) -> usize { #n }
                }
                impl l4::ipc::server::TypedBuffer<str> for #name {
                    #[inline]
                    fn copy_in(&mut self, i: &str) -> l4::error::Result<&mut str> {
                        if i.len() > self.__buffer.len() {
                            return Err(l4::error::Error::Generic(
                                l4::error::GenericErr::MsgTooLong));
                        }
                        Ok(unsafe {
                            core::ptr::copy_nonoverlapping(
                                i.as_ptr(), self.__buffer.as_mut_ptr(), i.len());
                            core::str::from_utf8_unchecked_mut(&mut self.__buffer[0..i.len()])
                        })
                    }
                }
                impl l4::ipc::server::TypedBuffer<[u8]> for #name {
                    #[inline]
                    fn copy_in(&mut self, i: &[u8]) -> l4::error::Result<&mut [u8]> {
                        if i.len() > self.__buffer.len() {
                            return Err(l4::error::Error::Generic(
                                l4::error::GenericErr::MsgTooLong));
                        }
                        Ok(unsafe {
                            core::ptr::copy_nonoverlapping(
                                i.as_ptr(), self.__buffer.as_mut_ptr(), i.len());
                            &mut self.__buffer[0..i.len()]
                        })
                    }
                }
            },
        ),
    };

    let gen = quote! {
        #[repr(C)]
        #(#attrs)*
        #vis struct #name #generics {
            __dispatch_ptr: l4::ipc::Callback,
            __cap: l4::cap::CapIdx,
            #(#field_iter,)*
            #cmember
            __pin: core::marker::PhantomPinned
        }

        impl #name {
            /// Create a new #name instance
            ///
            /// The first argument is the IPC gate that this server is bound to.
            /// For example: `#name::new(my_cap, #(#arg_names),*)`.
            fn new(cap: l4::cap::CapIdx, #(#arg_names: #arg_types),*) -> #name {
                #name {
                    __dispatch_ptr: l4::ipc::server_impl_callback::<#name>,
                    __cap: cap,
                    #(#initialiser_names,)*
                    #cnew
                    __pin: core::marker::PhantomPinned
                }
            }
        }
        unsafe impl l4::ipc::types::Callable for #name { }
        impl l4::ipc::types::Dispatch for #name {
            #[inline]
            fn dispatch(&mut self, tag: l4::ipc::MsgTag,
                        mr: &mut l4::utcb::UtcbMr,
                        bufs: &mut l4::ipc::BufferAccess)
                    -> l4::error::Result<l4::ipc::MsgTag> {
                // op_dispatch is auto-generated by the iface! macro
                self.op_dispatch(tag, mr, bufs)
            }
        }
        impl l4::ipc::Demand for #name {
            const CAP_DEMAND: u8 = <Self as #trait_name>::CAP_DEMAND;
        }
        impl l4::cap::Interface for #name {
            #[inline]
            fn raw(&self) -> l4::cap::CapIdx {
                self.__cap
            }
        }
        impl l4::ipc::CapProviderAccess for #name {
            unsafe fn access_buffers(&mut self) -> l4::ipc::BufferAccess {
                panic!("Not implemented for servers");
            }
        }
        #cimpl
    };
    gen.into()
}

pub fn parse_client_meta(meta: syn::AttributeArgs) -> Result<(Ident, u32)> {
    let mut traitname = None;
    let mut demand = 0;
    for item in meta {
        let item = match item {
            NestedMeta::Meta(m) => m,
            NestedMeta::Literal(l) => err!(l, "Literals not allowed"),
        };
        match item {
            Meta::Word(tn) => traitname = Some(tn),
            Meta::NameValue(nv) => {
                if nv.ident != "demand" {
                    err!(nv.ident, "Only `demand = NUM` allowed");
                }
                demand = match nv.lit {
                    Lit::Int(i) => i.value() as u32,
                    _ => err!(nv.ident, "Demand can only be a positive integer number"),
                };
            }
            Meta::List(ml) => err!(ml, "Invalid nesting of attributes"),
        };
    }
    if traitname.is_none() {
        err!("No IPC interface trait specified");
    }
    Ok((traitname.unwrap(), demand))
}

pub fn gen_client_struct(
    name: proc_macro2::Ident,
    attrs: Vec<Attribute>,
    vis: Visibility,
    generics: Generics,
    trait_name: Ident,
    demand: u32,
) -> proc_macro::TokenStream {
    let slot_type: syn::Type = match demand {
        0 => syn::parse(TokenStream::from_str("l4::ipc::Bufferless").unwrap()).unwrap(),
        _ => syn::parse(TokenStream::from_str("l4::ipc::BufferManager").unwrap()).unwrap(),
    };
    let gen = quote! {
        #(#attrs)*
        #vis struct #name #generics {
            __cap: l4::cap::CapIdx,
            __slots: #slot_type,
            __pin: core::marker::PhantomPinned,
        }

        impl l4::cap::Interface for #name {
            #[inline]
            fn raw(&self) -> l4::cap::CapIdx {
                self.__cap
            }
        }
        impl l4::cap::IfaceInit for #name {
            fn new(c: l4::cap::CapIdx) -> Self {
                #name {
                    __cap: c,
                    __slots: <#slot_type as l4::ipc::CapProvider>::new(),
                    __pin: core::marker::PhantomPinned,
                }
            }
        }
        impl #trait_name for #name { }

        impl l4::ipc::CapProviderAccess for #name {
            unsafe fn access_buffers(&mut self) -> l4::ipc::BufferAccess {
                use l4::ipc::CapProvider;
                self.__slots.access_buffers()
            }
        }
    };
    gen.into()
}

pub fn parse_server_meta(meta: syn::AttributeArgs) -> Result<ServerAttrs> {
    let mut trait_name = None;
    let mut buffer = 0; // stack buffer to store intermediate data
    for item in meta {
        let item = match item {
            NestedMeta::Meta(m) => m,
            NestedMeta::Literal(l) => err!(l, "Literals not allowed"),
        };
        match item {
            Meta::Word(tn) => trait_name = Some(tn),
            Meta::NameValue(nv) => {
                if nv.ident != "buffer" {
                    err!(nv.ident, "Only `demand = NUM` allowed");
                }
                buffer = match nv.lit {
                    Lit::Int(ref i) if i.value() > 500 => {
                        err!(nv.ident, "Cache size may not exceed 500 bytes")
                    }
                    Lit::Int(i) => i.value() as usize,
                    _ => err!(nv.ident, "Buffer size must be a positive integer"),
                };
            }
            Meta::List(ml) => err!(ml, "Invalid nesting of attributes"),
        };
    }
    let trait_name = match trait_name {
        None => err!("No IPC interface trait specified"),
        Some(x) => x,
    };
    Ok(ServerAttrs { trait_name, buffer })
}
